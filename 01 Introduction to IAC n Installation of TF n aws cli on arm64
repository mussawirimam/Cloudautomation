Infrasturcture as code IAC is the managing and prvisioning of infrastructure through code instead of through manual processes.
Some of the tools listed below which falls under IAC

terraform
aws cloudformation
puppet 
chef
ansible
saltstack

Key Features of Terraform:
Execution Plans
Resource Graph
Change automation

INSTALLATION ON ARM64 UBUNTU:
--------------------------------------------------------------------------------------------------------------------------------------------------------
official documentation: https://developer.hashicorp.com/terraform/install#linux
https://releases.hashicorp.com

sudo apt update
sudo apt install -y gnupg software-properties-common curl

curl -fsSL https://apt.releases.hashicorp.com/gpg | \
gpg --dearmor | \
sudo tee /usr/share/keyrings/hashicorp-archive-keyring.gpg > /dev/null

echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] \
https://apt.releases.hashicorp.com $(lsb_release -cs) main" | \
sudo tee /etc/apt/sources.list.d/hashicorp.list

sudo apt update
sudo apt install terraform

OR MANUAL INSTALLATION
wget https://releases.hashicorp.com/terraform/1.0.10/terraform_1.0.10_linux_arm64.zip
sudo apt install -y unzip
unzip terraform_1.0.10_linux_arm64.zip
sudo mv terraform /usr/local/bin/
sudo chmod +x /usr/local/bin/terraform

INSTALLATION AWS CLI ON ARM64 UBUNTU TO CONFIGURE AWS CREDENTIALS TO RUN TERRAFORM API CALLS:
--------------------------------------------------------------------------------------------------------------------------------------------------------
curl "https://awscli.amazonaws.com/awscli-exe-linux-aarch64.zip" -o "awscliv2.zip"
1. Download AWS CLI v2 for ARM64
curl "https://awscli.amazonaws.com/awscli-exe-linux-aarch64.zip" -o "awscliv2.zip"
2. Unzip
sudo apt update
sudo apt install -y unzip
unzip awscliv2.zip
3. Install to proper system paths
sudo ./aws/install -i /usr/local/aws-cli -b /usr/local/bin
This places:
Binary → /usr/local/bin/aws
Files → /usr/local/aws-cli
No PATH variable needed (same reason as Terraform).
4. Verify
aws --version
uname -m
You should see:
aws-cli/2.x.x Python/... Linux/aarch64
aarch64
5. Configure credentials
aws configure


NOW WHAT? 
----------
TERRAFORM ACCESS MODEL — STUDY NOTE
--------------------------------------------------------------------------------------------------------------------------------------------------------

CORE IDEA
Terraform does NOT own your cloud account.
Terraform is a CLIENT that talks to your cloud APIs.

It creates/updates/deletes resources by acting as an identity in your account.


WHY TERRAFORM NEEDS ACCESS
- Terraform makes a plan.
- To apply the plan, it must authenticate to the cloud.
- It performs API calls AS a user/service account.


BEST PRACTICE — DEDICATED TERRAFORM IDENTITY

Do NOT use your personal login.

Terraform is automation → use a machine identity.

Benefits:
- Security
- Audit logs show "Terraform did this"
- Follows least privilege principle


WHAT YOU CREATE

+---------------------------+----------------------------------+
| Component                 | Purpose                          |
+---------------------------+----------------------------------+
| IAM User / Service Acct  | Identity Terraform will use      |
| Access Keys / Creds      | Used by Terraform to login      |
| IAM Policy / Role        | What Terraform is allowed to do |
+---------------------------+----------------------------------+


PRINCIPLE — LEAST PRIVILEGE

Give Terraform ONLY the permissions it needs.

Think:
Terraform = robot employee with a limited badge


FLOW

   [Terraform]
        |
        v
[Uses IAM Identity / Service Account]
        |
        v
[Calls Cloud Provider API]
        |
        v
[Resources get created in your account]


MENTAL MODEL

Terraform --> IAM Identity --> Cloud API --> Infrastructure

--------------------------------------------------------------------------------------------------------------------------------------------------------
TERRAFORM WORKFLOW (ASCII)

FILES YOU WRITE
----------------
main.tf   variables.tf   outputs.tf   providers.tf


STEP 1 — INIT
--------------
terraform init

[Downloads provider plugins]
[Sets up backend for state]
[Prepares working directory]


STEP 2 — VALIDATE (optional but good)
-------------------------------------
terraform validate

[Checks syntax and structure of .tf files]


STEP 3 — PLAN
--------------
terraform plan

        Your .tf code
             |
             v
      [Current terraform.tfstate]
             |
             v
     [Queries real cloud resources]
             |
             v
   Shows execution plan (diff)

Output:
+ create
~ update
- destroy


STEP 4 — APPLY
---------------
terraform apply

        Plan
         |
         v
 [Uses IAM credentials]
         |
         v
 [Calls Cloud Provider APIs]
         |
         v
[Creates/updates resources]

State file is UPDATED


STEP 5 — STATE
---------------
terraform.tfstate

Tracks what Terraform created and its real IDs in the cloud.


STEP 6 — CHANGE SOMETHING
--------------------------
Edit .tf files → repeat PLAN → APPLY


STEP 7 — DESTROY (if needed)
-----------------------------
terraform destroy

Reads state → deletes everything it created.


FULL FLOW

 .tf files
     |
     v
terraform init
     |
     v
terraform plan  ---> compares ---> state + real cloud
     |
     v
terraform apply ---> calls cloud API
     |
     v
terraform.tfstate updated



--------------------------------------------------------------------------------------------------------------------------------------------------------
TF SYNTAX:

### we have different providers and provider plugins
### provider plugins have the libraries of all the confiugrations that the terraform uses.

resource "aws_vpc" "myvpc" {
  cidr_block = var.base_cidr_block
}

<BLOCK TYPE> "<BLOCK LABEL>" "<BLOCK LABEL>" {
  # Block body

  <IDENTIFIER> = <EXPRESSION>   # Argument
}
