Note:
1. If you have multiple resources, example resource A, resource B and there is no dependencies. The terraform will try to execute code for both at the same time.
2. If there are dependency of the resources, then terraform will go through sequence.

RANDOM PROVIDER FROM THE REGISTRY
=================================
https://registry.terraform.io/providers/hashicorp/random/latest

when working with any provider, there are required and optional input. You can use those through the 
documentation that the provider comes with. 

### added random provider
root@terra:~/introduction# cat providers.tf 
terraform {
  required_providers {
    local = {
      source = "hashicorp/local"
      version = "2.5.3"
    }
  }
}
    random = {
      source = "hashicorp/random"
      version = "3.8.1"
    }
  }
}

### added the code
resource "local_file" "myfirstfile" {
  filename  = "terraform_file.txt!"
    content   = "This is a first file created by Terraform."
}
resource "random_pet" "mypetname" {
    length = 2
    prefix = "MR"
    separator = "."
}

### but it is giving me error when I do plan because any time we add a new provider, we need to initialize the terraform to download the plugins for the new provider for the code to work. 
root@terra:~/introduction# terraform plan
╷
│ Error: Inconsistent dependency lock file
│ 
│ The following dependency selections recorded in the lock file are inconsistent with the current configuration:
│   - provider registry.terraform.io/hashicorp/local: locked version selection 2.5.3 doesn't match the updated version constraints "2.5.2"
│   - provider registry.terraform.io/hashicorp/random: required by this configuration but no version is selected
│ 
│ To update the locked dependency selections to match a changed configuration, run:
│   terraform init -upgrade
╵
root@terra:~/introduction# 

### I did upgrade because I previously had version 2.5.2 selected but in your case only TF init should work.

TERRAFORM WORKFLOW BEGINS AGAIN
===================================
root@terra:~/introduction# terraform init -upgrade #<-------------------------
Initializing the backend...
Initializing provider plugins...
- Finding hashicorp/local versions matching "2.5.3"...
- Finding hashicorp/random versions matching "3.8.1"...
- Using previously-installed hashicorp/local v2.5.3
- Installing hashicorp/random v3.8.1...
- Installed hashicorp/random v3.8.1 (signed by HashiCorp)
Terraform has made some changes to the provider dependency selections recorded
in the .terraform.lock.hcl file. Review those changes and commit them to your
version control system if they represent changes you intended to make.

Terraform has been successfully initialized!

You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.
root@terra:~/introduction# 

root@terra:~/introduction# ls
1  my-first-terraform.tf  providers.tf  terraform.tfstate  terraform.tfstate.backup

root@terra:~/introduction# terraform fmt #<-------------------------
my-first-terraform.tf
providers.tf
root@terra:~/introduction# cat my-first-terraform.tf 
resource "local_file" "myfirstfile" {
  filename = "terraform_file.txt!"
  content  = "This is a first file created by Terraform."
}
resource "random_pet" "mypetname" {
  length    = 2
  prefix    = "MR"
  separator = "."
}
root@terra:~/introduction# 

root@terra:~/introduction# terraform validate #<-------------------------
Success! The configuration is valid.

root@terra:~/introduction# 


root@terra:~/introduction# terraform plan   #<-------------------------

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the
following symbols:
  + create

Terraform will perform the following actions:

  # local_file.myfirstfile will be created  #<------------------------- creates this resources
  + resource "local_file" "myfirstfile" {
      + content              = "This is a first file created by Terraform."
      + content_base64sha256 = (known after apply)
      + content_base64sha512 = (known after apply)
      + content_md5          = (known after apply)
      + content_sha1         = (known after apply)
      + content_sha256       = (known after apply)
      + content_sha512       = (known after apply)
      + directory_permission = "0777"
      + file_permission      = "0777"
      + filename             = "terraform_file.txt!"
      + id                   = (known after apply)
    }

  # random_pet.mypetname will be created    #<------------------------- creates this resources
  + resource "random_pet" "mypetname" {
      + id        = (known after apply)
      + length    = 2
      + prefix    = "MR"
      + separator = "."
    }

Plan: 2 to add, 0 to change, 0 to destroy.

────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Note: You didn't use the -out option to save this plan, so Terraform can't guarantee to take exactly these actions if
you run "terraform apply" now.
root@terra:~/introduction# 

root@terra:~/introduction# terraform apply  #<-------------------------

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the
following symbols:
  + create

Terraform will perform the following actions:

  # local_file.myfirstfile will be created  #<-------------------------
  + resource "local_file" "myfirstfile" {
      + content              = "This is a first file created by Terraform."
      + content_base64sha256 = (known after apply)
      + content_base64sha512 = (known after apply)
      + content_md5          = (known after apply)
      + content_sha1         = (known after apply)
      + content_sha256       = (known after apply)
      + content_sha512       = (known after apply)
      + directory_permission = "0777"
      + file_permission      = "0777"
      + filename             = "terraform_file.txt!"
      + id                   = (known after apply)
    }

  # random_pet.mypetname will be created    #<-------------------------
  + resource "random_pet" "mypetname" {
      + id        = (known after apply)
      + length    = 2
      + prefix    = "MR"
      + separator = "."
    }

Plan: 2 to add, 0 to change, 0 to destroy.

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes

random_pet.mypetname: Creating...   #<-------------------------
random_pet.mypetname: Creation complete after 0s [id=MR.unique.egret]   #<-------------------------
local_file.myfirstfile: Creating... #<-------------------------
local_file.myfirstfile: Creation complete after 0s [id=c133f8b1adde00ab5d0f90679ae3a1c418094726] #<-------------------------

Apply complete! Resources: 2 added, 0 changed, 0 destroyed. #<-------------------------
root@terra:~/introduction# 

### right now this is random resource is only the word it got created but it (TF) will not store it somewhere, we have to use it/make use of it. And that is something we will learn.

### for now we will learn interpolation sequence
INTERPOLATION SEQUENCE
=======================
${}
Use case when you generate a pet name for example through the random provider, you can use that in other resrouces like in local_file provider resources within the content of the file
resource "local_file" "myfirstfile" {
  filename  = "terraform_file.txt!"
    content   = "This is a first file created by Terraform. And my pet name is${random_pet.mypetname.id}" ### <------------------- this is a interpolation sequence.
}
resource "random_pet" "mypetname" {
    length = 2
    prefix = "MR"
    separator = "."
}


root@terra:~/introduction# terraform plan

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the
following symbols:
  + create

Terraform will perform the following actions:

  # local_file.myfirstfile will be created
  + resource "local_file" "myfirstfile" {
      + content              = (known after apply)
      + content_base64sha256 = (known after apply)
      + content_base64sha512 = (known after apply)
      + content_md5          = (known after apply)
      + content_sha1         = (known after apply)
      + content_sha256       = (known after apply)
      + content_sha512       = (known after apply)
      + directory_permission = "0777"
      + file_permission      = "0777"
      + filename             = "terraform_file.txt!"
      + id                   = (known after apply)  # <----------------code need to be interpreted 
    }

  # random_pet.mypetname will be created
  + resource "random_pet" "mypetname" {
      + id        = (known after apply)
      + length    = 2
      + prefix    = "MR"
      + separator = "."
    }

Plan: 2 to add, 0 to change, 0 to destroy.

────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Note: You didn't use the -out option to save this plan, so Terraform can't guarantee to take exactly these actions if
you run "terraform apply" now.
root@terra:~/introduction# 

### now there is a dependency, first one will get created and then another 
### the file will get created and the id will be added to it
root@terra:~/introduction# terraform apply

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the
following symbols:
  + create

Terraform will perform the following actions:

  # local_file.myfirstfile will be created
  + resource "local_file" "myfirstfile" {
      + content              = (known after apply)
      + content_base64sha256 = (known after apply)
      + content_base64sha512 = (known after apply)
      + content_md5          = (known after apply)
      + content_sha1         = (known after apply)
      + content_sha256       = (known after apply)
      + content_sha512       = (known after apply)
      + directory_permission = "0777"
      + file_permission      = "0777"
      + filename             = "terraform_file.txt!"
      + id                   = (known after apply)
    }

  # random_pet.mypetname will be created
  + resource "random_pet" "mypetname" {
      + id        = (known after apply)
      + length    = 2
      + prefix    = "MR"
      + separator = "."
    }

Plan: 2 to add, 0 to change, 0 to destroy.

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes

random_pet.mypetname: Creating...
random_pet.mypetname: Creation complete after 0s [id=MR.relieved.beagle] ###<--------------
local_file.myfirstfile: Creating...
local_file.myfirstfile: Creation complete after 0s [id=e6f2069a0c699d3288f411128be4ce00145a9981] ###<--------------

Apply complete! Resources: 2 added, 0 changed, 0 destroyed.
root@terra:~/introduction# 
root@terra:~/introduction# ls
 my-first-terraform.tf   providers.tf  'terraform_file.txt!'   terraform.tfstate   terraform.tfstate.backup
root@terra:~/introduction# cat 'terraform_file.txt!' ###<--------------
This is a first file created by Terraform. And my pet name isMR.relieved.beagle ###<--------------
root@terra:~/introduction# 

### refereing the name of the resource 2 in resource 1, we used interpolation sequence
### if you scroll below and see in offical documentation for the resources, you will see the insertion of interpolation sequence as well. ${} ### <----------------------

# dependencies - 2 types - 1. implicit 2. explicit
############## < put notes 21-5-2025 from 2933 here > ############## 


|----------------------------------------------------------------------------------------------------------|
VARIABLES
==========
Q: What are the variables?
A: variable is a label, which holds some value. 

Note: always try to create a variable when creating the resources!
If you arent doing that, it will be difficult to manage the code. 
Example: if you have hardcoded a name at 20 different places, next time when you are changing that name, you will have to change that name 20 different times. But, if you have variabalized/parameterized it, you will have to change it only once. It's a best practice.

What are the variable block?
there are three essentials to give when coding. 
1. what is the default value.
2. type of the value.
3. custom description.
============================================================
            TERRAFORM STUDY NOTE — VARIABLES
============================================================

CORE RULE
---------
Always create variables instead of hardcoding values
inside resources.


------------------------------------------------------------
PROBLEM: HARDCODING
------------------------------------------------------------

resource "aws_instance" "example1" {
  tags = {
    Name = "production-server"
  }
}

resource "aws_s3_bucket" "example2" {
  bucket = "production-server"
}

If "production-server" appears in 20 places:

Change required?
    ↓
You must modify it 20 times manually.

Risks:
- Miss one location
- Inconsistent configuration
- Human error
- Poor maintainability


------------------------------------------------------------
SOLUTION: VARIABLE (PARAMETERIZATION)
------------------------------------------------------------

variable "environment_name" {
  type    = string
  default = "production-server"
}

resource "aws_instance" "example1" {
  tags = {
    Name = var.environment_name
  }
}

resource "aws_s3_bucket" "example2" {
  bucket = var.environment_name
}

Now:

Change required?
    ↓
Modify variable once
    ↓
All resources update automatically


------------------------------------------------------------
VISUAL COMPARISON
------------------------------------------------------------

Hardcoded Model:

   Resource A ---> "prod"
   Resource B ---> "prod"
   Resource C ---> "prod"

Change needed?
   Edit A
   Edit B
   Edit C
   (Manual repetition)


Variable Model:

         variable "env" = "prod"
                  |
                  v
   Resource A ---> var.env
   Resource B ---> var.env
   Resource C ---> var.env

Change needed?
   Edit variable only once
   All resources updated


------------------------------------------------------------
ENGINEERING PRINCIPLE
------------------------------------------------------------

DRY Principle
Don't Repeat Yourself

Hardcoding  = Tight Coupling
Variables   = Loose Coupling


------------------------------------------------------------
BEST PRACTICE RULE
------------------------------------------------------------

If a value:
- Might change later
- Is reused more than once
- Differs per environment (dev/stage/prod)

→ Make it a variable.


------------------------------------------------------------
SUMMARY
------------------------------------------------------------

Hardcoding:
  Short-term convenience
  Long-term maintenance pain

Variables:
  Clean architecture
  Scalable infrastructure
  Professional Terraform design
============================================================


--------------------------------------------------------------------------------------------------------------
PRACTICAL:
================

VARIABLE BLOCK:
===============
BEFORE CHANGES
--------------
### before specifying/calling the variable into the actual resource
resource "local_file" "myfirstfile" {
  filename  = "terraform_file.txt!"
    content   = "This is a first file created by Terraform. And my pet name is${random_pet.mypetname.id}"
}
resource "random_pet" "mypetname" {
    length = 2
    prefix = "MR"
    separator = "."
}

variable "filename" {
    default = "myfile.txt"
    type = string
    description = "Name of the file to create"
}

variable "file_content" {
    default = "This is the first file created using terraform"
    type = string
    description = "The content of the file"
}

AFTER CHANGES
--------------
### after the variables have been called
### resource
cat <<'eof'>  my-first-terraform.tf
resource "local_file" "myfirstfile" {
  filename  = var.filename  #<--------------- calling the variable
    content   = var.file_content  #<--------------- calling the variable
}
resource "random_pet" "mypetname" {
    length = 2
    prefix = "MR"
    separator = "."
}
### variables
variable "filename" {
    default = "myfile.txt"
    type = string
    description = "Name of the file to create"
}

variable "file_content" {
    default = "This is the first file created using terraform"
    type = string
    description = "The content of the file"
}
eof

root@terra:~/introduction# terraform plan
random_pet.mypetname: Refreshing state... [id=MR.relieved.beagle]
local_file.myfirstfile: Refreshing state... [id=e6f2069a0c699d3288f411128be4ce00145a9981]

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the
following symbols:
-/+ destroy and then create replacement

Terraform will perform the following actions:

  # local_file.myfirstfile must be replaced
-/+ resource "local_file" "myfirstfile" {
      ~ content              = "This is a first file created by Terraform. And my pet name isMR.relieved.beagle" -> "This is the first file created using terraform" # forces replacement
      ~ content_base64sha256 = "7AW/LwrpKUcto06Ht2pf0JX/QoW8O1BG2OIVGA2NWhA=" -> (known after apply)
      ~ content_base64sha512 = "DNl352/39eeOGOzVDjJRlkyr+6Dr9Z6aBe1TkTRG49vCkBJrKUQJ16fos6GM2lDqevLv74r4+PlOfQbb4SmSLw==" -> (known after apply)
      ~ content_md5          = "8f1e9c9ef9c4718bc4f1db5db0fb3ccc" -> (known after apply)
      ~ content_sha1         = "e6f2069a0c699d3288f411128be4ce00145a9981" -> (known after apply)
      ~ content_sha256       = "ec05bf2f0ae929472da34e87b76a5fd095ff4285bc3b5046d8e215180d8d5a10" -> (known after apply)
      ~ content_sha512       = "0cd977e76ff7f5e78e18ecd50e3251964cabfba0ebf59e9a05ed53913446e3dbc290126b294409d7a7e8b3a18cda50ea7af2efef8af8f8f94e7d06dbe129922f" -> (known after apply)
      ~ filename             = "terraform_file.txt!" -> "myfile.txt" # forces replacement
      ~ id                   = "e6f2069a0c699d3288f411128be4ce00145a9981" -> (known after apply)
        # (2 unchanged attributes hidden)
    }

Plan: 1 to add, 0 to change, 1 to destroy.

────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Note: You didn't use the -out option to save this plan, so Terraform can't guarantee to take exactly these actions if
you run "terraform apply" now.
root@terra:~/introduction# 

root@terra:~/introduction# terraform apply 
local_file.myfirstfile: Refreshing state... [id=e6f2069a0c699d3288f411128be4ce00145a9981]
random_pet.mypetname: Refreshing state... [id=MR.relieved.beagle]

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the
following symbols:
-/+ destroy and then create replacement

Terraform will perform the following actions:

  # local_file.myfirstfile must be replaced
-/+ resource "local_file" "myfirstfile" {
      ~ content              = "This is a first file created by Terraform. And my pet name isMR.relieved.beagle" -> "This is the first file created using terraform" # forces replacement
      ~ content_base64sha256 = "7AW/LwrpKUcto06Ht2pf0JX/QoW8O1BG2OIVGA2NWhA=" -> (known after apply)
      ~ content_base64sha512 = "DNl352/39eeOGOzVDjJRlkyr+6Dr9Z6aBe1TkTRG49vCkBJrKUQJ16fos6GM2lDqevLv74r4+PlOfQbb4SmSLw==" -> (known after apply)
      ~ content_md5          = "8f1e9c9ef9c4718bc4f1db5db0fb3ccc" -> (known after apply)
      ~ content_sha1         = "e6f2069a0c699d3288f411128be4ce00145a9981" -> (known after apply)
      ~ content_sha256       = "ec05bf2f0ae929472da34e87b76a5fd095ff4285bc3b5046d8e215180d8d5a10" -> (known after apply)
      ~ content_sha512       = "0cd977e76ff7f5e78e18ecd50e3251964cabfba0ebf59e9a05ed53913446e3dbc290126b294409d7a7e8b3a18cda50ea7af2efef8af8f8f94e7d06dbe129922f" -> (known after apply)
      ~ filename             = "terraform_file.txt!" -> "myfile.txt" # forces replacement
      ~ id                   = "e6f2069a0c699d3288f411128be4ce00145a9981" -> (known after apply)
        # (2 unchanged attributes hidden)
    }

Plan: 1 to add, 0 to change, 1 to destroy.

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes

local_file.myfirstfile: Destroying... [id=e6f2069a0c699d3288f411128be4ce00145a9981]
local_file.myfirstfile: Destruction complete after 0s
local_file.myfirstfile: Creating...
local_file.myfirstfile: Creation complete after 0s [id=0a0cd87c97d0d36d8ec98c240b3aa48989f04324]

Apply complete! Resources: 1 added, 0 changed, 1 destroyed.
root@terra:~/introduction# 

root@terra:~/introduction# ls
myfile.txt  my-first-terraform.tf  providers.tf  terraform.tfstate  terraform.tfstate.backup
root@terra:~/introduction# cat my
myfile.txt             my-first-terraform.tf  
root@terra:~/introduction# cat myfile.txt 
This is the first file created using terraform
root@terra:~/introduction# 

### NOTE: terraform will not plan if the variable value or type isnt specified. 
### variables should be in specified file called variable.tf and not to be added in the main.tf files
root@terra:~/introduction# ls
 main.tf       'terraform_file.txt!'   terraform.tfstate.backup
 providers.tf   terraform.tfstate      variables.tf
root@terra:~/introduction# 




OUTPUT BLOCK
=============
### output block will help you to print the output. 
### for now we will add it to the same code but we will break these in seperate files. 

### resource block
resource "local_file" "myfirstfile" {
  filename  = var.filename
    content   = var.file_content
}
resource "random_pet" "mypetname" {
    length = 2
    prefix = "MR"
    separator = "."
}

### output block
output "my_pet_name"{
    value = random_pet.mypetname.id ##
}


root@terra:~/introduction# terraform apply
random_pet.mypetname: Refreshing state... [id=MR.relieved.beagle]
local_file.myfirstfile: Refreshing state... [id=e6f2069a0c699d3288f411128be4ce00145a9981]

No changes. Your infrastructure matches the configuration.

Terraform has compared your real infrastructure against your configuration and found no
differences, so no changes are needed.

Apply complete! Resources: 0 added, 0 changed, 0 destroyed.

Outputs:

my_pet_name = "MR.relieved.beagle"  #<----------------------
root@terra:~/introduction# 

### where the output will be used? there is a concept called module. There are two projects like vpc and vpc id needs to be refered into another project as input
one state file 
########## < put notes here explains at 21-5-2025 4714 > ###########

FILE STRUCTURE:
root@terra:~/introduction# tree
.
├── main.tf
├── myfile.txt
├── providers.tf
├── terraform.tfstate
├── terraform.tfstate.backup
└── variables.tf

1 directory, 6 files
root@terra:~/introduction# 
