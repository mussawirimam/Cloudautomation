Note:
1. If you have multiple resources, example resource A, resource B and there is no dependencies. The terraform will try to execute code for both at the same time.
2. If there are dependency of the resources, then terraform will go through sequence.

RANDOM PROVIDER FROM THE REGISTRY
=================================
https://registry.terraform.io/providers/hashicorp/random/latest

when working with any provider, there are required and optional input. You can use those through the 
documentation that the provider comes with. 

### added random provider
root@terra:~/introduction# cat providers.tf 
terraform {
  required_providers {
    local = {
      source = "hashicorp/local"
      version = "2.5.3"
    }
  }
}
    random = {
      source = "hashicorp/random"
      version = "3.8.1"
    }
  }
}

### added the code
resource "local_file" "myfirstfile" {
  filename  = "terraform_file.txt!"
    content   = "This is a first file created by Terraform."
}
resource "random_pet" "mypetname" {
    length = 2
    prefix = "MR"
    separator = "."
}

### but it is giving me error when I do plan because any time we add a new provider, we need to initialize the terraform to download the plugins for the new provider for the code to work. 
root@terra:~/introduction# terraform plan
╷
│ Error: Inconsistent dependency lock file
│ 
│ The following dependency selections recorded in the lock file are inconsistent with the current configuration:
│   - provider registry.terraform.io/hashicorp/local: locked version selection 2.5.3 doesn't match the updated version constraints "2.5.2"
│   - provider registry.terraform.io/hashicorp/random: required by this configuration but no version is selected
│ 
│ To update the locked dependency selections to match a changed configuration, run:
│   terraform init -upgrade
╵
root@terra:~/introduction# 

### I did upgrade because I previously had version 2.5.2 selected but in your case only TF init should work.

TERRAFORM WORKFLOW BEGINS AGAIN
===================================
root@terra:~/introduction# terraform init -upgrade #<-------------------------
Initializing the backend...
Initializing provider plugins...
- Finding hashicorp/local versions matching "2.5.3"...
- Finding hashicorp/random versions matching "3.8.1"...
- Using previously-installed hashicorp/local v2.5.3
- Installing hashicorp/random v3.8.1...
- Installed hashicorp/random v3.8.1 (signed by HashiCorp)
Terraform has made some changes to the provider dependency selections recorded
in the .terraform.lock.hcl file. Review those changes and commit them to your
version control system if they represent changes you intended to make.

Terraform has been successfully initialized!

You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.
root@terra:~/introduction# 

root@terra:~/introduction# ls
1  my-first-terraform.tf  providers.tf  terraform.tfstate  terraform.tfstate.backup

root@terra:~/introduction# terraform fmt #<-------------------------
my-first-terraform.tf
providers.tf
root@terra:~/introduction# cat my-first-terraform.tf 
resource "local_file" "myfirstfile" {
  filename = "terraform_file.txt!"
  content  = "This is a first file created by Terraform."
}
resource "random_pet" "mypetname" {
  length    = 2
  prefix    = "MR"
  separator = "."
}
root@terra:~/introduction# 

root@terra:~/introduction# terraform validate #<-------------------------
Success! The configuration is valid.

root@terra:~/introduction# 


root@terra:~/introduction# terraform plan   #<-------------------------

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the
following symbols:
  + create

Terraform will perform the following actions:

  # local_file.myfirstfile will be created  #<------------------------- creates this resources
  + resource "local_file" "myfirstfile" {
      + content              = "This is a first file created by Terraform."
      + content_base64sha256 = (known after apply)
      + content_base64sha512 = (known after apply)
      + content_md5          = (known after apply)
      + content_sha1         = (known after apply)
      + content_sha256       = (known after apply)
      + content_sha512       = (known after apply)
      + directory_permission = "0777"
      + file_permission      = "0777"
      + filename             = "terraform_file.txt!"
      + id                   = (known after apply)
    }

  # random_pet.mypetname will be created    #<------------------------- creates this resources
  + resource "random_pet" "mypetname" {
      + id        = (known after apply)
      + length    = 2
      + prefix    = "MR"
      + separator = "."
    }

Plan: 2 to add, 0 to change, 0 to destroy.

────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Note: You didn't use the -out option to save this plan, so Terraform can't guarantee to take exactly these actions if
you run "terraform apply" now.
root@terra:~/introduction# 

root@terra:~/introduction# terraform apply  #<-------------------------

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the
following symbols:
  + create

Terraform will perform the following actions:

  # local_file.myfirstfile will be created  #<-------------------------
  + resource "local_file" "myfirstfile" {
      + content              = "This is a first file created by Terraform."
      + content_base64sha256 = (known after apply)
      + content_base64sha512 = (known after apply)
      + content_md5          = (known after apply)
      + content_sha1         = (known after apply)
      + content_sha256       = (known after apply)
      + content_sha512       = (known after apply)
      + directory_permission = "0777"
      + file_permission      = "0777"
      + filename             = "terraform_file.txt!"
      + id                   = (known after apply)
    }

  # random_pet.mypetname will be created    #<-------------------------
  + resource "random_pet" "mypetname" {
      + id        = (known after apply)
      + length    = 2
      + prefix    = "MR"
      + separator = "."
    }

Plan: 2 to add, 0 to change, 0 to destroy.

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes

random_pet.mypetname: Creating...   #<-------------------------
random_pet.mypetname: Creation complete after 0s [id=MR.unique.egret]   #<-------------------------
local_file.myfirstfile: Creating... #<-------------------------
local_file.myfirstfile: Creation complete after 0s [id=c133f8b1adde00ab5d0f90679ae3a1c418094726] #<-------------------------

Apply complete! Resources: 2 added, 0 changed, 0 destroyed. #<-------------------------
root@terra:~/introduction# 

### right now this is random resource is only the word it got created but it (TF) will not store it somewhere, we have to use it/make use of it. And that is something we will learn.

### for now we will learn interpolation sequence
INTERPOLATION SEQUENCE
=======================
${}
Use case when you generate a pet name for example through the random provider, you can use that in other resrouces like in local_file provider resources within the content of the file
resource "local_file" "myfirstfile" {
  filename  = "terraform_file.txt!"
    content   = "This is a first file created by Terraform. And my pet name is${random_pet.mypetname.id}" ### <------------------- this is a interpolation sequence.
}
resource "random_pet" "mypetname" {
    length = 2
    prefix = "MR"
    separator = "."
}


root@terra:~/introduction# terraform plan

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the
following symbols:
  + create

Terraform will perform the following actions:

  # local_file.myfirstfile will be created
  + resource "local_file" "myfirstfile" {
      + content              = (known after apply)
      + content_base64sha256 = (known after apply)
      + content_base64sha512 = (known after apply)
      + content_md5          = (known after apply)
      + content_sha1         = (known after apply)
      + content_sha256       = (known after apply)
      + content_sha512       = (known after apply)
      + directory_permission = "0777"
      + file_permission      = "0777"
      + filename             = "terraform_file.txt!"
      + id                   = (known after apply)  # <----------------code need to be interpreted 
    }

  # random_pet.mypetname will be created
  + resource "random_pet" "mypetname" {
      + id        = (known after apply)
      + length    = 2
      + prefix    = "MR"
      + separator = "."
    }

Plan: 2 to add, 0 to change, 0 to destroy.

────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Note: You didn't use the -out option to save this plan, so Terraform can't guarantee to take exactly these actions if
you run "terraform apply" now.
root@terra:~/introduction# 

### now there is a dependency, first one will get created and then another 
### the file will get created and the id will be added to it
root@terra:~/introduction# terraform apply

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the
following symbols:
  + create

Terraform will perform the following actions:

  # local_file.myfirstfile will be created
  + resource "local_file" "myfirstfile" {
      + content              = (known after apply)
      + content_base64sha256 = (known after apply)
      + content_base64sha512 = (known after apply)
      + content_md5          = (known after apply)
      + content_sha1         = (known after apply)
      + content_sha256       = (known after apply)
      + content_sha512       = (known after apply)
      + directory_permission = "0777"
      + file_permission      = "0777"
      + filename             = "terraform_file.txt!"
      + id                   = (known after apply)
    }

  # random_pet.mypetname will be created
  + resource "random_pet" "mypetname" {
      + id        = (known after apply)
      + length    = 2
      + prefix    = "MR"
      + separator = "."
    }

Plan: 2 to add, 0 to change, 0 to destroy.

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes

random_pet.mypetname: Creating...
random_pet.mypetname: Creation complete after 0s [id=MR.relieved.beagle] ###<--------------
local_file.myfirstfile: Creating...
local_file.myfirstfile: Creation complete after 0s [id=e6f2069a0c699d3288f411128be4ce00145a9981] ###<--------------

Apply complete! Resources: 2 added, 0 changed, 0 destroyed.
root@terra:~/introduction# 
root@terra:~/introduction# ls
 my-first-terraform.tf   providers.tf  'terraform_file.txt!'   terraform.tfstate   terraform.tfstate.backup
root@terra:~/introduction# cat 'terraform_file.txt!' ###<--------------
This is a first file created by Terraform. And my pet name isMR.relieved.beagle ###<--------------
root@terra:~/introduction# 

### refereing the name of the resource 2 in resource 1, we used interpolation sequence
### if you scroll below and see in offical documentation for the resources, you will see the insertion of interpolation sequence as well. ${} ### <----------------------

# dependencies - 2 types - 1. implicit 2. explicit
############## < put notes 21-5-2025 from 2933 here > ############## 


|----------------------------------------------------------------------------------------------------------|
VARIABLES
==========
always try to create a variable when creating the resources!
If you arent doing that, it will be difficult to manage the code. 
Example: if you have hardcoded a name at 20 different places, next time when you are changing that name, you will have to change that name 20 different times. But, if you have variabalized/parameterized it, you will have to change it only once. It's a best practice.
============================================================
            TERRAFORM STUDY NOTE — VARIABLES
============================================================

CORE RULE
---------
Always create variables instead of hardcoding values
inside resources.


------------------------------------------------------------
PROBLEM: HARDCODING
------------------------------------------------------------

resource "aws_instance" "example1" {
  tags = {
    Name = "production-server"
  }
}

resource "aws_s3_bucket" "example2" {
  bucket = "production-server"
}

If "production-server" appears in 20 places:

Change required?
    ↓
You must modify it 20 times manually.

Risks:
- Miss one location
- Inconsistent configuration
- Human error
- Poor maintainability


------------------------------------------------------------
SOLUTION: VARIABLE (PARAMETERIZATION)
------------------------------------------------------------

variable "environment_name" {
  type    = string
  default = "production-server"
}

resource "aws_instance" "example1" {
  tags = {
    Name = var.environment_name
  }
}

resource "aws_s3_bucket" "example2" {
  bucket = var.environment_name
}

Now:

Change required?
    ↓
Modify variable once
    ↓
All resources update automatically


------------------------------------------------------------
VISUAL COMPARISON
------------------------------------------------------------

Hardcoded Model:

   Resource A ---> "prod"
   Resource B ---> "prod"
   Resource C ---> "prod"

Change needed?
   Edit A
   Edit B
   Edit C
   (Manual repetition)


Variable Model:

         variable "env" = "prod"
                  |
                  v
   Resource A ---> var.env
   Resource B ---> var.env
   Resource C ---> var.env

Change needed?
   Edit variable only once
   All resources updated


------------------------------------------------------------
ENGINEERING PRINCIPLE
------------------------------------------------------------

DRY Principle
Don't Repeat Yourself

Hardcoding  = Tight Coupling
Variables   = Loose Coupling


------------------------------------------------------------
BEST PRACTICE RULE
------------------------------------------------------------

If a value:
- Might change later
- Is reused more than once
- Differs per environment (dev/stage/prod)

→ Make it a variable.


------------------------------------------------------------
SUMMARY
------------------------------------------------------------

Hardcoding:
  Short-term convenience
  Long-term maintenance pain

Variables:
  Clean architecture
  Scalable infrastructure
  Professional Terraform design
============================================================
